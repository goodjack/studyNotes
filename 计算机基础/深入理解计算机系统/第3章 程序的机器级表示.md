### x86-64 指令集

| C 声明 | Intel 数据类型 | 汇编代码后缀 | 大小（字节） |
| ------ | -------------- | ------------ | ------------ |
| char   | 字节           | b            | 1            |
| short  | 字             | w            | 2            |
| int    | 双字           | l            | 4            |
| long   | 四字           | q            | 8            |
| char*  | 四字           | q            | 8            |
| float  | 单精度         | s            | 4            |
| double | 双精度         | l            | 8            |

`$-177 或 $0x1F` 表示立即数

### 数据传送指令

将数据从一个位置复制到另一个位置的指令。

| 指令        | 描述         |
| ----------- | ------------ |
| movb S,D    | 传送字节     |
| movw S,D    | 传送字       |
| movl S,D    | 传送双字     |
| movq S,D    | 传送四字     |
| movabsq S,D | 传送绝对四字 |

### 压入和弹出栈数据

**栈是一种数据结构，遵循先进后出原则**

| 指令    | 描述         |
| ------- | ------------ |
| pushq S | 将四字压入栈 |
| popq D  | 将四字弹出栈 |

### 算术和逻辑操作

#### 加载有效地址

加载有效地址（load effective address）指令 leaq 实际上是 movq 指令的变形。

它的指令形式是从内存读数据到寄存器。

| 指令     | 描述         |
| -------- | ------------ |
| leaq S,D | 加载有效地址 |

#### 一元操作

一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。

| 指令  | 描述 |
| ----- | ---- |
| INC D | 加 1 |
| DEC D | 减 1 |
| NEG D | 取负 |
| NOT D | 取补 |

#### 二元操作

二元操作，第二个操作数既是源又是目的。

第一个操作数可以是立即数、寄存器或内存位置。

第二个操作数可以是寄存器或是内存位置。

例：

```
subq %rax,%rdx # 表示 %rdx = %rdx - %rax
```

| 指令     | 描述 |
| -------- | ---- |
| add S,D  | 加   |
| sub S,D  | 减   |
| imul S,D | 乘   |
| xor S,D  | 异或 |
| or S,D   | 或   |
| and S,D  | 与   |

#### 移位

移位操作，先给出移位量，然后第二项给出的是要移位的数。

移位量可以是立即数，或是放在单字节寄存器 %cl 中。

例：当寄存器 %cl 的十六进制值为 0xFF 时，指令 salb 会移 7 位，salw 会移 15 位，sall 会移 31 位，salq 会移 63 位。

移位操作数的目的操作数可以是一个寄存器或一个内存位置。

| 指令    | 描述               |
| ------- | ------------------ |
| sal K,D | 左移               |
| shl K,D | 左移（等同于 sal） |
| sar K,D | 算术右移           |
| shr K,D | 逻辑右移           |

#### 特殊的算术操作

| 指令    | 描述         |
| ------- | ------------ |
| imulq S | 有符号全乘法 |
| mulq S  | 无符号全乘法 |
| cqto    | 转换为八字   |
| idivq S | 有符号除法   |
| divq S  | 无符号除法   |

### 控制
#### 条件码
常用条件码：
- CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
- ZF：零标志。最近的操作得出结果为 0。
- SF：符号标志。最近的操作得到的结果为负数。
- OF：溢出标志。最近的操作导致一个补码溢出（正溢出或负溢出）。

#### 跳转指令

jmp 指令是无条件跳转。它可以是无条件跳转，即跳转目标是作为指令的一部分编码；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。

### 缓冲区溢出（buffer overflow）

缓冲区溢出攻击，恶意用户会输入超过缓冲区的内容，把覆盖原本的内容覆盖，使得程序执行意外的函数，此时执行的函数就会是恶意的攻击代码。

**对抗缓冲区溢出攻击：**

- 栈随机化（address space layout randomization）

> 在程序开始时，在栈上分配一段 0~n 字节之间的随机大小空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化，分配的范围 n 必须是一个合适的大小，这样才能获得足够多的栈地址变化，且不至于浪费太多的空间。

- 栈破坏检测

> GCC 版本产生的代码中加入了一种栈保护者（stack protector）机制，是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的值，称为哨兵值（guard value），是在程序每次运行时随机产生的。因此，攻击者不知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个哨兵值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了，如果哨兵值被改变了，程序异常终止。

- 限制可执行代码区域

> 限制哪些内存区域能够存放可执行代码。只有保存编译器产生的代码的那部分内存才需要是可执行的。其它部分可以被限制为只允许读和写。